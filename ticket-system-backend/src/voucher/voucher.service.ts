import { Injectable, ForbiddenException } from '@nestjs/common';
import { PrismaService } from 'src/prisma/prisma.service';
import { CreateVoucherDto } from './dto/create-voucher.dto';
import { Voucher } from 'generated/prisma';

@Injectable()
export class VoucherService {
  constructor(private prisma: PrismaService) { }

  async create(createVoucherDto: CreateVoucherDto, eventId: string): Promise<Voucher> {
    const { reduce_type, reduce_price, price, start_date, end_date } = createVoucherDto;

    const whereClause = { event_id: eventId }
    let createdVoucher: Voucher | null = null;
    const maxAttempts = 5;

    for (let attempt = 0; attempt < maxAttempts; attempt++) {
      // load existing codes (scoped to event if eventId provided)
      const existing = await this.prisma.voucher.findMany({
        where: whereClause,
        select: { code: true }
      });

      let maxNum = existing.reduce((max, v) => {
        if (!v.code) return max;
        const m = v.code.match(/(\d+)$/);
        if (!m) return max;
        const n = parseInt(m[1], 10);
        return Number.isNaN(n) ? max : Math.max(max, n);
      }, 0);

      maxNum += 1;
      const generatedCode = String(maxNum).padStart(3, '0'); // "001", "002", ...

      const data: any = {
        code: generatedCode,
        reduce_type,
        reduce_price,
        price,
        start_date,
        end_date
      };

      if (eventId) {
        data.event = { connect: { id: eventId } };
      }

      try {
        createdVoucher = await this.prisma.voucher.create({ data });
        break; // success
      } catch (err: any) {
        // handle duplicate key / unique constraint and retry
        const isUniqueError = err?.code === 'P2002' || (err?.message && err.message.includes('duplicate key'));
        if (!isUniqueError) {
          throw err;
        }
        // else duplicate code generated by concurrent request -> retry
      }
    }

    if (!createdVoucher) {
      throw new ForbiddenException('Failed to create voucher');
    }

    return createdVoucher;
  }

  async findAll() {
    return await this.prisma.voucher.findMany({
      where: {
        end_date: {
          gte: new Date()
        }
      },
      orderBy: {
        start_date: 'desc'
      }
    });
  }

  async findOne(id: string) {
    const voucher = await this.prisma.voucher.findUnique({
      where: { id }
    });

    if (!voucher) {
      throw new ForbiddenException('Voucher not found');
    }

    return voucher;
  }

  async remove(id: string) {
    await this.prisma.voucher.delete({
      where: { id }
    });

    return { message: 'Voucher deleted successfully' };
  }
}